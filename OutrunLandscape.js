//Animation Algorythm Isabel Carvalho
//the concept is a terrain simulation inspired by the outrun franchise
var scl = 80;
var w = 5000; //the max for keeping good fr is about 3000
var h = 4000; //the max for keeping good fr is about 3000
var cols = w/scl, rows = h/scl;
var flying = 0; // it moves the noise space

var terrain = []; // a two dimensional array allow for storage of the positions generated by perlin noise


function setup() {
  canvas = createCanvas(windowWidth, windowHeight, WEBGL); 
  terrain = [...Array(round(cols))].map(x => [...Array(round(rows))]);
  canvas.position(0,0);
  canvas.style('z-index', '-21');
  canvas.style('width', '100%')


}


function draw() {
    //console.log(frameRate())
    push();
     flying -= 0.12; // if you do += instead it moves backwards
  var yoff = flying;

  for (var y = 0; y < rows; y++) {
    var xoff = 0;
    for (var x = 0; x < cols; x++) {
      terrain[x][y] = map(noise(xoff, yoff), 0, 1, -350, 350); //to alter max terrain values
      //Makes the mountains higher and the valleys lower
      xoff += 0.2; // alters the jump through gradations, meaning in that in effect it smooths out the terrain
    }
    yoff += 0.2;
  }
  pointLight(10, 20, 200, 0, 0, -800);//Highlight Light
  //Since there aren't any costumizable materials the lights will create the color in this instance
  pointLight(120, 30, 131, 0, 0, 800); //purple blue
  pointLight(34, 0, 114, 0, -800, 0); //deeper blue
  pointLight(34, 0, 114, 0, 800, 0);//backup light

  //background(20, 100, 100);
  background(8, 28, 43);
  translate(50, 200, -400); // this one changes the distance of the "camera"
  noStroke();
  stroke(168,228,226);
  strokeWeight(0.6);
  rotateX(PI / 2.5); // changes the "camera angle" relative to the terrain, the "camera" itself being static
  ambientMaterial(255);
  
  //normalMaterial();
  translate(-w / 2, -h / 3); // altering this can also mimic a camera being more distant from the landscape

  for (var y = 0; y < rows - 1; y++) {
    beginShape(TRIANGLE_STRIP);
    for (var x = 0; x < cols; x++) {
      vertex(x * scl, y * scl, terrain[x][y]);
      vertex(x * scl, (y + 1) * scl, terrain[x][y + 1]);
    }
    endShape();
    //noLoop();
  }
  pop();

}

